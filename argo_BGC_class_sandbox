import requests # dependency for icepyx
import pandas as pd # dependency for icepyx? - geopandas
import os
from .dataset import *

class Argo_bgc(DataSet):

#  Argo data object to search/download (in one function) for BGC Argo data. 

%spatial_extent : list or string
#       Spatial extent of interest, provided as a bounding box, list of polygon coordinates, or
#        geospatial polygon file.
#        Bounding box coordinates should be provided in decimal degrees as
#        [lower-left-longitude, lower-left-latitute, upper-right-longitude, upper-right-latitude].
#        Polygon coordinates should be provided as coordinate pairs in decimal degrees as
#        [(longitude1, latitude1), (longitude2, latitude2), ... (longitude_n,latitude_n), (longitude1,latitude1)]
#        or
#        [longitude1, latitude1, longitude2, latitude2, ... longitude_n,latitude_n, longitude1,latitude1].

% timeframe: list (2) of start date and end date, in YYYY-MM-DD

% meas1, meas2 = string listing of argo measurement, e.g., bbp700, chla, temp, psal, doxy

    def __init__(self, shape, timeframe, meas1, meas2, presRange=None):
        self.shape = shape
        self.bounding_box = shape.extent # call coord standardization method (see icepyx)
        self.time_frame = timeframe # call fmt_timerange
        self.meas1 = meas1
        self.meas2 = meas2
        self.presrng = presRange

    def download(self, out_path):
        baseURL = 'https://argovis.colorado.edu/selection/bgc_data_selection'
        meas1Query = '?meas_1=' + self.meas1
        meas2Query = '&meas_2=' + self.meas2
        startDateQuery = '&startDate=' + self.time_frame[0].strftime('%Y-%m-%d')
        endDateQuery = '&endDate=' + self.time_frame[1].strftime('%Y-%m-%d')

        shapeQuery = '&shape=' + self.shape # might have to process this
        if not self.presrng == None:
            pressRangeQuery = '&presRange=' + self.presrng
            url = baseURL + meas1Query + meas2Query + startDateQuery + endDateQuery + pressRangeQuery + '&bgcOnly=true' + shapeQuery
        else:
            url = baseURL + meas1Query + meas2Query + startDateQuery + endDateQuery + '&bgcOnly=true' + shapeQuery
        resp = requests.get(url)

        # Consider any status other than 2xx an error
        if not resp.status_code // 100 == 2:
            return "Error: Unexpected response {}".format(resp)
        selectionProfiles = resp.json()

        # save selection profiles somewhere
        # return selectionProfiles

    # ----------------------------------------------------------------------
    # Properties

    @property
    def dataset(self):
        """
        Return the short name dataset ID string associated with the query object.
        
        """
        return self._dset

    @property
    def spatial_extent(self):
        """
        Return an array showing the spatial extent of the query object.
        Spatial extent is returned as an input type (which depends on how
        you initially entered your spatial data) followed by the geometry data.
        Bounding box data is [lower-left-longitude, lower-left-latitute, upper-right-longitude, upper-right-latitude].
        Polygon data is [[array of longitudes],[array of corresponding latitudes]].

        """

        if self.extent_type == "bounding_box":
            return ["bounding box", self._spat_extent]
        elif self.extent_type == "polygon":
            # return ['polygon', self._spat_extent]
            # Note: self._spat_extent is a shapely geometry object
            return ["polygon", self._spat_extent.exterior.coords.xy]
        else:
            return ["unknown spatial type", None]

    @property
    def dates(self):
        """
        Return an array showing the date range of the query object.
        Dates are returned as an array containing the start and end datetime objects, inclusive, in that order.
        
        """
        return [
            self._start.strftime("%Y-%m-%d"),
            self._end.strftime("%Y-%m-%d"),
        ]  # could also use self._start.date()

    @property
    def start_time(self):
        """
        Return the start time specified for the start date.
        NOTE THAT there is no time input for Argo
        """
        return self._start.strftime("%H:%M:%S")

    @property
    def end_time(self):
        """
        Return the end time specified for the end date.
        Examples
        """
        return self._end.strftime("%H:%M:%S")

## DO WE NEED AN ORDER VARS CLASS? or the download already puts data into a dataframe .. maybe order vars could 
# save data to CSV? 
# IF SO, this code may be relevant for it 

tick1 = 0
tick2 = 0
for index, value in enumerate(selectionProfiles):
    if meas1 not in value['bgcMeasKeys']:
        tick1 += 1
    if meas2 not in value['bgcMeasKeys']:
        tick2 += 1  
if tick1 == len(selectionProfiles):
    print(f'{meas1} not found in selected data') 
if tick2 == len(selectionProfiles):
    print(f'{meas2} not found in selected data')     
                    
if tick1 < len(selectionProfiles) & tick2 < len(selectionProfiles):
    df = json2dataframe(selectionProfiles, measKey='bgcMeas')

df.head()

# NEED TO ADD CODE for the visualization here
def visualize_spatial_extent(
        self,
    ):  # additional args, basemap, zoom level, cmap, export
        """
        Creates a map displaying the input spatial extent
        Examples
        --------
        >>> icepyx.query.Query('ATL06','path/spatialfile.shp',['2019-02-22','2019-02-28'])
        >>> reg_a.visualize_spatial_extent
        [visual map output]
        """

        world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))
        f, ax = plt.subplots(1, figsize=(12, 6))
        world.plot(ax=ax, facecolor="lightgray", edgecolor="gray")
        geospatial.geodataframe(self.extent_type, self._spat_extent).plot(
            ax=ax, color="#FF8C00", alpha=0.7
        )
        plt.show()